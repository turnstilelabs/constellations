<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sharp phase transition for the random-cluster and Potts models via decision trees</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <!-- MATHJAX INTEGRATION -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          packages: {'[+]': ['ams']},
          macros: {
            bbE: '\\mathbb{E}',
            bbP: '\\mathbb{P}',
            bbZ: '\\mathbb{Z}',
            bbR: '\\mathbb{R}',
            bbG: '\\mathbb{G}',
            bbH: '\\mathbb{H}',
            bbV: '\\mathbb{V}',
            mathbbm: ['{\\mathbf{#1}}', 1],
            mathbbm1: '\\mathbf{1}',
            llbracket: '\\mathopen{[\\![}',
            rrbracket: '\\mathclose{]\\!]}'
          }
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
          ignoreHtmlClass: 'tex2jax_ignore'
        },
        startup: {
          pageReady: () => {
            return MathJax.startup.defaultPageReady();
          }
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f8f9fa; color: #333; }
        .header { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
        h1 { margin: 0 0 10px 0; font-size: 24px; }
        .authors { 
            font-style: italic;
            color: #555;
            margin: -5px 0 15px 0;
        }
        .arxiv-link { display: inline-block; vertical-align: middle; margin: 0 5px; }
        .arxiv-icon { width: 22px; height: 22px; color: #2E8B57; transition: transform 0.2s ease-in-out; }
        .arxiv-link:hover .arxiv-icon { transform: scale(1.15); color: #3CB371; }
        .stats { display: flex; align-items: center; gap: 20px; flex-wrap: wrap; margin-top: 15px; }
        .stat { background: #e9ecef; padding: 8px 12px; border-radius: 4px; font-size: 14px; }
        .graph-container { position: relative; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; }
        .controls { padding: 15px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .center-button-header { padding: 6px 12px; border: 1px solid #dee2e6; background: white; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background-color 0.2s; }
        .center-button-header:hover { background: #e9ecef; }
        .legend-container { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .legend { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
        .legend-title { font-weight: bold; font-size: 12px; margin-right: -5px; }
        .legend-item { display: flex; align-items: center; gap: 5px; font-size: 12px; cursor: pointer; user-select: none; }
        .legend-item.inactive { opacity: 0.4; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; }
        .edge-legend-line { width: 20px; height: 2px; }
        #graph { width: 100%; height: 80vh; cursor: grab; }
        #graph:active { cursor: grabbing; }
        .node, .link, .node-label { transition: opacity 0.3s ease-in-out; }
        .faded { opacity: 0.1; }
        .node { stroke: #fff; stroke-width: 2px; cursor: pointer; }
        .node:hover { stroke: #000; }
        .link { stroke-opacity: 0.7; stroke-width: 1.5px; transition: stroke-width 0.2s, stroke-opacity 0.2s; cursor: pointer; }
        .link:hover { stroke-width: 4px; stroke-opacity: 1; }
        .node-label { font-size: 12px; fill: #333; text-anchor: middle; pointer-events: none; font-weight: 500; }
        .tooltip { position: absolute; background: rgba(0, 0, 0, 0.9); color: white; padding: 12px; border-radius: 6px; font-size: 14px; pointer-events: none; max-width: 450px; z-index: 1000; line-height: 1.6; border: 1px solid #333; }
        #info-panel { position: absolute; top: 0; right: 0; width: 350px; max-width: 90%; height: 100%; background: #fff; box-shadow: -2px 0 8px rgba(0,0,0,0.15); transform: translateX(105%); transition: transform 0.3s ease-in-out; z-index: 1001; display: flex; flex-direction: column; }
        #info-panel.visible { transform: translateX(0); }
        .info-header { padding: 15px; border-bottom: 1px solid #dee2e6; display: flex; justify-content: space-between; align-items: center; }
        .info-header h2 { font-size: 16px; margin: 0; }
        .close-btn { font-size: 24px; font-weight: bold; cursor: pointer; color: #888; border: none; background: none; }
        .info-content { padding: 15px; overflow-y: auto; color: #333; }
        .info-content h4 { margin-top: 15px; margin-bottom: 5px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Sharp phase transition for the random-cluster and Potts models via decision trees</h1>
        <p class="authors">By Hugo Duminil-Copin, Aran Raoufi, Vincent Tassion</p>
        <p>
            <strong>Paper ID:</strong> 1705.03104
            <a href="https://arxiv.org/abs/1705.03104" target="_blank" title="View on arXiv" class="arxiv-link">
                <svg class="arxiv-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M14.52 16.59L12.9 14.53L14.42 12.37L12.9 10.2L14.52 8.14L18.24 12.37M9.48 16.59L11.1 14.53L9.58 12.37L11.1 10.2L9.48 8.14L5.76 12.37M12 2A10 10 0 0 0 2 12A10 10 0 0 0 12 22A10 10 0 0 0 22 12A10 10 0 0 0 12 2Z"></path></svg>
            </a> | <strong>Generated:</strong> 2025-11-15 20:58:32
        </p>
        <div class="stats">
            <div class="stat"><strong>16</strong> artifacts</div>
            <div class="stat"><strong>25</strong> dependencies</div>
            <button id="center" class="center-button-header">ðŸ”„ Reset View</button>
        </div>
    </div>
    <div class="graph-container">
        <div class="controls">
            <div class="legend-container">
                <span class="legend-title">Nodes:</span>
                <div class="legend" id="node-legend-container"></div>
            </div>
            <div class="legend-container">
                <span class="legend-title">Dependencies:</span>
                <div class="legend" id="edge-legend-container"></div>
            </div>
        </div>
        <svg id="graph"></svg>
        <div id="info-panel">
            <div class="info-header">
                <h2 id="info-title"></h2>
                <button class="close-btn" id="close-info-panel">&times;</button>
            </div>
            <div class="info-content" id="info-body"></div>
        </div>
    </div>
    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        const graphData = {
          "nodes": [
            { "id": "theorem-1-8adf0c", "type": "theorem", "content_preview": "Fix an increasing function $f:\\{0,1\\}^E\\longrightarrow [0,1]$ on a finite set $E$. For any monotonic measure $\\mu$ and any decision tree $T$,  $\\begin{equation} \\mathrm{Var}_\\mu(f)~\\le~   ...\\end{equation}$", "prerequisites_preview": "$E$: Consider a finite set $E$ of cardinality $n$.\n\n$\\mu$: A \\emph{monotonic} measure is a measure $\\mu$ on ${0,1}^{E}$ such that for any $e \\in E$, any $F \\subset E$, and any $\\xi,\\zeta \\in {0,1}^{F}$ satisfying $\\xi \\le  \\zeta $, $\\mu[\\omega_e=\\xi_e,\\forall e \\in F]>0$ and  $\\mu[\\omega_e=\\zeta_e,\\forall e \\in F]>0$,   $$\\mu[\\omega_e=1 :|: \\omega_e=\\xi_e,\\forall e \\in F] \\le \\mu[\\omega_e=1 :|: \\omega_e=\\zeta_e,\\forall e \\in F].$$ \n\n$\\omega$: A decision tree associated to a Boolean function $f$ takes $\\omega\\in\\{0,1\\}^n$ as an input, and reveals algorithmically the value of $\\omega$ in different bits one by one.\n\ndecision tree: To start with a more tractable problem, computer scientists have studied \\emph{decision trees}, which are simpler models of computation. A decision tree associated to a Boolean function $f$ takes $\\omega\\in\\{0,1\\}^n$ as an input, and reveals algorithmically the value of $\\omega$ in different bits one by one.\n\nrevealment: When $\\tau$ is taken to be the time at which $f$ is determined, the $\\tau$-revealment simply corresponds to the standard notion of revealment associated to a random decision tree.", "display_name": "Theorem 1.1", "label": "thm:OSSS" },
            { "id": "theorem-2-9c9e2e", "type": "theorem", "content_preview": "Fix $q \\geq 1$ and consider the random-cluster model on a weighted lattice $(\\bbG, J)$.\nThen,\n- There exists $c>0$ such that $\\theta(\\beta)\\ge c(\\beta-\\beta_c)$ for any $\\beta \\ge \\beta_c$ close enough to $\\beta_c$.\n- For any $\\beta<\\beta_c$ there exists $c_\\beta>0$ such that for every $n\\ge0$,\n$$\\phi_{\\Lambda_n,\\beta,q}^{\\rm w}[0\\longleftrightarrow \\partial\\Lambda_n]\\le \\exp[-c_\\beta n].$$", "prerequisites_preview": "$J$: Introduce a family of \\emph{non-negative} coupling constants $J=(J_{xy})_{xy\\in \\bbE}\\in[0,\\infty)^\\bbE$ which is non-zero and invariant under a group acting transitively on $\\bbV$.\n\n$\\Lambda_n$: Finally, let $\\Lambda_n$ be the box of size $n$ around $0$ for the graph distance.\n\nweighted lattice: Introduce a family of \\emph{non-negative} coupling constants $J=(J_{xy})_{xy\bbE} [0,\\infty)^E$ which is non-zero and invariant under a group acting transitively on $V$. Notice that the coupling constants are necessarily finite-range (since the graph is locally finite). We call the pair $(\\bbG,J)$ a \\emph{weighted lattice}.", "display_name": "Theorem 1.2", "label": "thm:RCM" },
            { "id": "theorem-3-e7e3ea", "type": "theorem", "content_preview": "Fix $q\\ge1$. If $y_c:=p_c/(1-p_c)$, we have  $$\\begin{array}{ll}\ny_c^2-q=0&\\text{on the square lattice,} \\\\\ny_c^3+3y_c^2-q=0  & \\text{on the triangular lattice,}\\\\\ny_c^3-3qy_c-q^2=0 & \\text{on the hexagonal lattice.}\\end{array}$$", "prerequisites_preview": "", "display_name": "Theorem 1.3", "label": "thm:planarRCM" },
            { "id": "theorem-4-f84e6f", "type": "theorem", "content_preview": "Fix $q\\ge1$ and a planar locally-finite doubly periodic graph $\\bbG$. We have  \n\\begin{equation}\\frac{p_c(\\bbG)p_c(\\bbG^*)}{(1-p_c(\\bbG))(1-p_c(\\bbG^*))}= q.\\end{equation}", "prerequisites_preview": "", "display_name": "Theorem 1.4", "label": "thm:dualRCM" },
            { "id": "theorem-5-ff5a6d", "type": "theorem", "content_preview": "There does not exist any translational invariant measure $\\mu$ on a planar locally-finite doubly periodic graph  $\\bbG$ satisfying:\n- {\\em (FKG)} For any increasing events $A$ and $B$,\n$\\mu(A\\cap B)\\ge \\mu(A)\\mu(B)$.\n- Almost surely, there exists a unique infinite connected component in $\\omega$ and in $\\omega^*$.", "prerequisites_preview": "$\\mu$: A \\emph{monotonic} measure is a measure $\\mu$ on ${0,1}^{E}$ such that for any $e \\in E$, any $F \\subset E$, and any $\\xi,\\zeta \\in {0,1}^{F}$ satisfying $\\xi \\le  \\zeta $, $\\mu[\\omega_e=\\xi_e,\\forall e \\in F]>0$ and  $\\mu[\\omega_e=\\zeta_e,\\forall e \\in F]>0$,   $$\\mu[\\omega_e=1 :|: \\omega_e=\\xi_e,\\forall e \\in F] \\le \\mu[\\omega_e=1 :|: \\omega_e=\\zeta_e,\\forall e \\in F].$$ \n\n$\\omega$: A decision tree associated to a Boolean function $f$ takes $\\omega\\in\\{0,1\\}^n$ as an input, and reveals algorithmically the value of $\\omega$ in different bits one by one.\n\n$\\omega^*$: For a configuration $\\omega$ on $\\bbG$, define a configuration $\\omega^*$ in $\\bbG^*$ by the formula $\\omega^*_{e^*}=1-\\omega_e$ for every edge $e$ of $\\bbG$, where $e^*$ is the edge of $\\bbG^*$ between the two vertices of $\\bbG^*$ corresponding to the faces bordered by $e$.", "display_name": "Theorem 1.5", "label": "thm:dual" },
            { "id": "theorem-6-38ae21", "type": "theorem", "content_preview": "Fix an integer $q\\ge2$ and consider the $q$-state Potts on a weighted lattice $(\\bbG,J)$. Then, for $\\beta<\\beta_c$,  there exists $c_\\beta>0$ such that for every $x\\in\\bbV$,\n$$0\\le\\mathbb P^\\nu_{\\Lambda_n,\\beta,q}[\\sigma_0=\\nu]-\\tfrac1q\\le \\exp[-c_\\beta n].$$", "prerequisites_preview": "$J$: Introduce a family of \\emph{non-negative} coupling constants $J=(J_{xy})_{xy\\in \\bbE}\\in[0,\\infty)^\\bbE$ which is non-zero and invariant under a group acting transitively on $\\bbV$.\n\n$\\Lambda_n$: Finally, let $\\Lambda_n$ be the box of size $n$ around $0$ for the graph distance.\n\nweighted lattice: Introduce a family of \\emph{non-negative} coupling constants $J=(J_{xy})_{xy\bbE} [0,\\infty)^E$ which is non-zero and invariant under a group acting transitively on $V$. Notice that the coupling constants are necessarily finite-range (since the graph is locally finite). We call the pair $(\\bbG,J)$ a \\emph{weighted lattice}.\n\n$\\nu$: For $G=(V,E)$ a finite subgraph of a weighted lattice $(\\bbG, J)$, $\\nu \\in \\{1, \\dots, q\\}$, and $\\beta\\ge0$, the {\\em $q$-state Potts measure} with boundary condition $\\nu$ is defined for any $\\sigma=(\\sigma_x)_{x\\in V}\\in \\{1,\\dots,q\\}^V$ by\n$$ \\mathbb P^{\\nu}_{G,\\beta,q}[\\sigma]~:=~\\frac{\\displaystyle \\exp  ( -\\beta H^\\nu_{G,q}(\\sigma) )}{\\displaystyle\\sum_{\\sigma'\\in\\{1,\\dots,q\\}^V}\\exp  ( -\\beta H^\\nu_{G,q}(\\sigma) )}$$ \n\n$q$-state Potts: The Potts model \\cite{Pot52} is one of the most fundamental example of a lattice spin model undergoing an order/disorder phase transition at a critical parameter $\\beta_c$. It generalizes the Ising model by allowing the spins to take one of $q$ values.", "display_name": "Theorem 1.6", "label": "thm:Potts" },
            { "id": "lemma-7-be03cd", "type": "lemma", "content_preview": "Let $\\U$ be a iid sequence of uniform $[0,1]$ random variables, and $\\e$ a random variable taking values in $\\vec E$. Assume that for every $1\\le t\\le n$, $\\U_t$ is independent of $(\\e_{[t]},\\U_{[t-1]})$, then...", "prerequisites_preview": "", "display_name": "Lemma 2.1", "label": "lem:01" },
            { "id": "remark-8-5102da", "type": "remark", "content_preview": "For most applications, one may replace covariances in the OSSS inequality by influences $I_e[f]:=\\mu (f|\\omega_e=1)-\\mu(f|\\omega_e=0)$ (we chose not to do so since applications in statistical physics to long-range models would for instance...", "prerequisites_preview": "$E$: Consider a finite set $E$ of cardinality $n$.\n\n$\\mu$: A \\emph{monotonic} measure is a measure $\\mu$ on ${0,1}^{E}$ such that for any $e \\in E$, any $F \\subset E$, and any $\\xi,\\zeta \\in {0,1}^{F}$ satisfying $\\xi \\le  \\zeta $, $\\mu[\\omega_e=\\xi_e,\\forall e \\in F]>0$ and  $\\mu[\\omega_e=\\zeta_e,\\forall e \\in F]>0$,   $$\\mu[\\omega_e=1 :|: \\omega_e=\\xi_e,\\forall e \\in F] \\le \\mu[\\omega_e=1 :|: \\omega_e=\\zeta_e,\\forall e \\in F].$$ \n\n$\\omega$: A decision tree associated to a Boolean function $f$ takes $\\omega\\in\\{0,1\\}^n$ as an input, and reveals algorithmically the value of $\\omega$ in different bits one by one.\n\n$F_e(u)$: For $u\\in[0,1]^n$ and $e\\in \\vec E$, define $F_e(u)=x$ inductively for $1\\le t\\le n$ by\n   \\begin{equation}\\label{eq:ccc}x_{e_t}:=\\begin{cases} 1&\\text{ if }u_{t}\\ge\\mu[\\omega_{e_{t}}=0\\,|\\,\\omega_{e_{[t-1]}}=x_{e_{[t-1]}}],\\\\   0&\\text{ otherwise}.\\end{cases}\\end{equation}\n\n$\\mathbb E$: Write $\\mathbb P$ for the coupling between these variables (and $\\mathbb E$ for its expectation).", "display_name": "Remark 2.2", "label": null },
            { "id": "remark-9-12ecba", "type": "remark", "content_preview": "Note that for the trivial decision tree discovering all the edges, for every edge the revealment is equal to 1 . As a consequence, we recover (in a very convoluted way) the discrete Poincar\\'e inequality...", "prerequisites_preview": "$E$: Consider a finite set $E$ of cardinality $n$.\n\ndecision tree: To start with a more tractable problem, computer scientists have studied \\emph{decision trees}, which are simpler models of computation. A decision tree associated to a Boolean function $f$ takes $\\omega\\in\\{0,1\\}^n$ as an input, and reveals algorithmically the value of $\\omega$ in different bits one by one.\n\nrevealment: When $\\tau$ is taken to be the time at which $f$ is determined, the $\\tau$-revealment simply corresponds to the standard notion of revealment associated to a random decision tree.", "display_name": "Remark 2.3", "label": "eq:poincare" },
            { "id": "remark-10-d4014e", "type": "remark", "content_preview": "The proof of the previous statement can be extended in a trivial way as follows. First, we may consider countable sets $E$ by using a very simple martingale argument. Second, we may consider that $\\tau$ is an arbitrary stopping time (with respect...", "prerequisites_preview": "$E$: Consider a finite set $E$ of cardinality $n$.\n\n$\\mu$: A \\emph{monotonic} measure is a measure $\\mu$ on ${0,1}^{E}$ such that for any $e \\in E$, any $F \\subset E$, and any $\\xi,\\zeta \\in {0,1}^{F}$ satisfying $\\xi \\le  \\zeta $, $\\mu[\\omega_e=\\xi_e,\\forall e \\in F]>0$ and  $\\mu[\\omega_e=\\zeta_e,\\forall e \\in F]>0$,   $$\\mu[\\omega_e=1 :|: \\omega_e=\\xi_e,\\forall e \\in F] \\le \\mu[\\omega_e=1 :|: \\omega_e=\\zeta_e,\\forall e \\in F].$$", "display_name": "Remark 2.4", "label": null },
            { "id": "theorem-11-b23168", "type": "theorem", "content_preview": "Fix a countable set $E$ and an increasing function $f:\\{0,1\\}^E\\longrightarrow [-1,1]$. For any monotonic measure $\\mu$ on $\\{0,1\\}^E$, any decision tree $T$ and any stopping time $\\tau$,  \\begin{equation}...\n\\end{equation}", "prerequisites_preview": "$E$: Consider a finite set $E$ of cardinality $n$.\n\n$\\mu$: A \\emph{monotonic} measure is a measure $\\mu$ on ${0,1}^{E}$ such that for any $e \\in E$, any $F \\subset E$, and any $\\xi,\\zeta \\in {0,1}^{F}$ satisfying $\\xi \\le  \\zeta $, $\\mu[\\omega_e=\\xi_e,\\forall e \\in F]>0$ and  $\\mu[\\omega_e=\\zeta_e,\\forall e \\in F]>0$,   $$\\mu[\\omega_e=1 :|: \\omega_e=\\xi_e,\\forall e \\in F] \\le \\mu[\\omega_e=1 :|: \\omega_e=\\zeta_e,\\forall e \\in F].$$ \n\ndecision tree: To start with a more tractable problem, computer scientists have studied \\emph{decision trees}, which are simpler models of computation. A decision tree associated to a Boolean function $f$ takes $\\omega\\in\\{0,1\\}^n$ as an input, and reveals algorithmically the value of $\\omega$ in different bits one by one.", "display_name": "Theorem 2.5", "label": "eq:OSSS2" },
            { "id": "lemma-12-5f7f28", "type": "lemma", "content_preview": "Consider a converging sequence of increasing differentiable functions $f_n:[0,\\beta_0]\\rightarrow [0,M]$ satisfying\n \\begin{equation}f_n'\\ge \\frac{n}{\\Sigma_{n}}f_n\n \\end{equation}\n for all... ", "prerequisites_preview": "", "display_name": "Lemma 3.1", "label": "lem:technical" },
            { "id": "lemma-13-bf8b5f", "type": "lemma", "content_preview": "Consider a finite graph $G=(V,E)$ containing $0$. For any monotonic measure $\\mu$ on $\\{0,1\\}^E$ and any $n\\ge1$, one has\n$$\\sum_{xy\\in E} {\\rm Cov}_\\mu(\\mathbbm...$$", "prerequisites_preview": "$E$: Consider a finite set $E$ of cardinality $n$.\n\n$\\mu$: A \\emph{monotonic} measure is a measure $\\mu$ on ${0,1}^{E}$ such that for any $e \\in E$, any $F \\subset E$, and any $\\xi,\\zeta \\in {0,1}^{F}$ satisfying $\\xi \\le  \\zeta $, $\\mu[\\omega_e=\\xi_e,\\forall e \\in F]>0$ and  $\\mu[\\omega_e=\\zeta_e,\\forall e \\in F]>0$,   $$\\mu[\\omega_e=1 :|: \\omega_e=\\xi_e,\\forall e \\in F] \\le \\mu[\\omega_e=1 :|: \\omega_e=\\zeta_e,\\forall e \\in F].$$ \n\n$\\Lambda_n$: Finally, let $\\Lambda_n$ be the box of size $n$ around $0$ for the graph distance.", "display_name": "Lemma 3.2", "label": "cor:OSSS" },
            { "id": "remark-14-c6c568", "type": "remark", "content_preview": "Note that $\\tau$ may a priori be strictly smaller than the last time we are in first case (since the decision tree may discover a path of open edges from 0 to $\\partial \\Lambda_n$ or a family of closed edges disconnecting the origin from...", "prerequisites_preview": "decision tree: To start with a more tractable problem, computer scientists have studied \\emph{decision trees}, which are simpler models of computation. A decision tree associated to a Boolean function $f$ takes $\\omega\\in\\{0,1\\}^n$ as an input, and reveals algorithmically the value of $\\omega$ in different bits one by one.\n\n$\\Lambda_n$: Finally, let $\\Lambda_n$ be the box of size $n$ around $0$ for the graph distance.", "display_name": "Remark 3.3", "label": null },
            { "id": "lemma-15-e0712e", "type": "lemma", "content_preview": "Assume that both $\\omega$ and $\\omega^*$ contain a unique infinite connected components almost surely. Then, as $\\min\\{n,k\\}$ tends to infinity,\n- $\\max\\big\\{h(n,k),v(n,k+1)\\big\\}$ tends to 1,\n- $\\min\\big\\{v(n,k),h(n,k)\\}$ tends to 0.", "prerequisites_preview": "$\\omega$: A decision tree associated to a Boolean function $f$ takes $\\omega\\in\\{0,1\\}^n$ as an input, and reveals algorithmically the value of $\\omega$ in different bits one by one.\n\n$\\omega^*$: For a configuration $\\omega$ on $\\bbG$, define a configuration $\\omega^*$ in $\\bbG^*$ by the formula $\\omega^*_{e^*}=1-\\omega_e$ for every edge $e$ of $\\bbG$, where $e^*$ is the edge of $\\bbG^*$ between the two vertices of $\\bbG^*$ corresponding to the faces bordered by $e$.", "display_name": "Lemma 4.1", "label": "lem:hg" },
            { "id": "external_Gri06", "type": "unknown", "display_name": "Reference [Gri06]", "label": "Gri06" }
          ],
          "edges": [
            { "source": "theorem-1-8adf0c", "target": "lemma-7-be03cd", "type": "internal", "dependency_type": "uses_result", "context": "{W} ^t$ is equal to $\\V$ if $t\\ge \\tau$).   Lemma~\\ref{lem:01} applied to $(\\U,\\e)$ gives that $\\X$ has law $\\mu" },
            { "source": "theorem-2-9c9e2e", "target": "external_Gri06", "type": "external", "dependency_type": "uses_result", "context": "$ Now, the comparison between boundary conditions \\cite[Lemma 4.14]{Gri06} together with the facts that $\\Lambda_{2k}(x)\\sub" },
            { "source": "theorem-2-9c9e2e", "target": "lemma-13-bf8b5f", "type": "internal", "dependency_type": "uses_result", "context": "_n$ is monotonic \\cite[Theorem 3.8]{Gri06}, Lemma~\\ref{cor:OSSS} (applied to the graph $G=(\\Lambda_{2n},E)$ induce" },
            { "source": "theorem-2-9c9e2e", "target": "lemma-12-5f7f28", "type": "internal", "dependency_type": "uses_result", "context": ") so that $\\theta_n$ converges to $\\theta$. Lemma~\\ref{lem:technical} applied to $f_n=\\theta_n/c$ gives the existence o" },
            { "source": "theorem-4-f84e6f", "target": "external_Gri06", "type": "external", "dependency_type": "uses_result", "context": "$\\omega^*_{e^*}=1-\\omega_e$, then the  duality  \\cite[Theorem 6.13]{Gri06} for random-cluster models states that $\\omega^*$" },
            { "source": "theorem-4-f84e6f", "target": "theorem-2-9c9e2e", "type": "internal", "dependency_type": "uses_result", "context": "(\\bbG)^*=p_c(\\bbG^*)$. The second item of Theorem~\\ref{thm:RCM}, for quasi-transitive graphs, implies that for an" },
            { "source": "theorem-4-f84e6f", "target": "theorem-5-ff5a6d", "type": "internal", "dependency_type": "uses_result", "context": "cted component almost surely). Therefore, Theorem~\\ref{thm:dual} shows that $p>p_c(\\bbG)$ implies $p^*\\le p_c(\\bbG" },
            { "source": "remark-8-5102da", "target": "lemma-7-be03cd", "type": "internal", "dependency_type": "uses_result", "context": "$\\mathbf W$ is independent of $\\U_{[t-1]}$. Lemma~\\ref{lem:01} and the fact that $f$ is increasing give us  $$ \\" },
            { "source": "lemma-13-bf8b5f", "target": "theorem-1-8adf0c", "type": "internal", "dependency_type": "uses_result", "context": "obtain the target inequality by applying Theorem~\\ref{thm:OSSS} for each $k$ and then summing on $k$. As a key, w" },
            { "source": "lemma-13-bf8b5f", "target": "theorem-11-b23168", "type": "uses_result", "dependency_type": "uses_result" },
            { "source": "remark-10-d4014e", "target": "theorem-1-8adf0c", "type": "is_generalization_of", "dependency_type": "is_generalization_of" },
            { "source": "theorem-6-38ae21", "target": "theorem-4-f84e6f", "type": "uses_result", "dependency_type": "uses_result" },
            { "source": "remark-14-c6c568", "target": "theorem-1-8adf0c", "type": "uses_definition", "dependency_type": "uses_definition" },
            { "source": "remark-9-12ecba", "target": "theorem-1-8adf0c", "type": "is_corollary_of", "dependency_type": "is_corollary_of" },
            { "source": "remark-14-c6c568", "target": "lemma-13-bf8b5f", "type": "uses_definition", "dependency_type": "uses_definition" },
            { "source": "theorem-6-38ae21", "target": "theorem-2-9c9e2e", "type": "is_corollary_of", "dependency_type": "is_corollary_of" },
            { "source": "remark-10-d4014e", "target": "remark-8-5102da", "type": "is_generalization_of", "dependency_type": "is_generalization_of" },
            { "source": "theorem-11-b23168", "target": "remark-10-d4014e", "type": "is_corollary_of", "dependency_type": "is_corollary_of" },
            { "source": "remark-14-c6c568", "target": "theorem-2-9c9e2e", "type": "provides_remark", "dependency_type": "provides_remark" },
            { "source": "remark-8-5102da", "target": "theorem-1-8adf0c", "type": "uses_result", "dependency_type": "uses_result" },
            { "source": "remark-14-c6c568", "target": "theorem-11-b23168", "type": "uses_definition", "dependency_type": "uses_definition" },
            { "source": "theorem-11-b23168", "target": "remark-9-12ecba", "type": "is_generalization_of", "dependency_type": "is_generalization_of" },
            { "source": "theorem-11-b23168", "target": "theorem-1-8adf0c", "type": "is_generalization_of", "dependency_type": "is_generalization_of" },
            { "source": "remark-14-c6c568", "target": "remark-10-d4014e", "type": "uses_definition", "dependency_type": "uses_definition" },
            { "source": "remark-10-d4014e", "target": "lemma-7-be03cd", "type": "uses_result", "dependency_type": "uses_result" }
          ]
        };
        const nodeTypes = [...new Set(graphData.nodes.map(d => d.type))];
        const edgeTypes = [...new Set(graphData.edges.map(d => d.dependency_type || "internal"))];
        
        const nodeColorScale = d3.scaleOrdinal(d3.schemeCategory10);
        const edgeColorScale = d3.scaleOrdinal(["#999", "#d62728", "#2ca02c", "#1f77b4", "#ff7f0e", "#9467bd"]);

        const nodeColors = nodeTypes.reduce((acc, type) => {
            acc[type] = nodeColorScale(type);
            return acc;
        }, {});
        const edgeColors = edgeTypes.reduce((acc, type) => {
            acc[type] = edgeColorScale(type);
            return acc;
        }, {});

        const svg = d3.select("#graph");
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;

        const defs = svg.append("defs");
        edgeTypes.forEach(type => {
            defs.append("marker")
                .attr("id", `arrowhead-${type}`)
                .attr("viewBox", "-0 -5 10 10")
                .attr("refX", 25)
                .attr("refY", 0)
                .attr("orient", "auto")
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", edgeColors[type]);
        });

        const zoom = d3.zoom().scaleExtent([0.1, 8]).on("zoom", (event) => g.attr("transform", event.transform));
        svg.call(zoom);
        const g = svg.append("g");
        
        const infoPanel = d3.select("#info-panel");
        const infoTitle = d3.select("#info-title");
        const infoBody = d3.select("#info-body");

        function hideInfoPanel() { infoPanel.classed("visible", false); }
        d3.select("#close-info-panel").on("click", hideInfoPanel);

        svg.on("click", () => {
            if (pinned) {
                pinned = false;
                pinnedNode = null;
                node.classed("faded", false);
                link.classed("faded", false);
                label.classed("faded", false);
                hideInfoPanel();
            }
        });
        
        const nodeDegrees = new Map();
        graphData.edges.forEach(edge => {
            nodeDegrees.set(edge.source, (nodeDegrees.get(edge.source) || 0) + 1);
            nodeDegrees.set(edge.target, (nodeDegrees.get(edge.target) || 0) + 1);
        });
        const radiusScale = d3.scaleSqrt().domain([0, d3.max(nodeDegrees.values())]).range([8, 20]);

        const simulation = d3.forceSimulation(graphData.nodes)
            .force("link", d3.forceLink(graphData.edges).id(d => d.id).distance(120))
            .force("charge", d3.forceManyBody().strength(-600))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(d => radiusScale(nodeDegrees.get(d.id) || 1) + 5));

        const link = g.append("g").selectAll("line")
            .data(graphData.edges).enter().append("line").attr("class", "link")
            .attr("stroke", d => edgeColors[d.dependency_type || "internal"])
            .attr("marker-end", d => `url(#arrowhead-${d.dependency_type || "internal"})`);

        const node = g.append("g").selectAll("circle")
            .data(graphData.nodes).enter().append("circle").attr("class", "node")
            .attr("r", d => radiusScale(nodeDegrees.get(d.id) || 1))
            .attr("fill", d => nodeColors[d.type] || '#ccc')
            .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

        const label = g.append("g").selectAll("text")
            .data(graphData.nodes).enter().append("text").attr("class", "node-label")
            .attr("dy", d => radiusScale(nodeDegrees.get(d.id) || 1) + 12)
            .text(d => d.display_name);

        const tooltip = d3.select("#tooltip");
        let pinned = false;
        let pinnedNode = null;
        
        function cleanLatexForDisplay(content) {
            if (!content) return '';
            return content.replace(/\\label\{[^}]*\}/g, '').trim();
        }

        function renderNodeTooltip(event, d) {
            const finalPreview = cleanLatexForDisplay(d.content_preview || 'N/A');
            tooltip.style("display", "block")
                .html(`<h4>${d.display_name}</h4><div class="math-content">${finalPreview}</div>`)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");

            MathJax.typesetPromise([tooltip.node()]).catch(err => console.error('MathJax typesetting failed:', err));
        }
        
        function hideTooltipIfNotPinned() {
            if (!pinned) {
                tooltip.style("display", "none");
            }
        }
        
        const neighboring = (a, b) => {
            return graphData.edges.some(edge => (edge.source.id === a.id && edge.target.id === b.id) || (edge.source.id === b.id && edge.target.id === a.id));
        };

        node.on("mouseover", (event, d) => {
            if (!pinned) renderNodeTooltip(event, d);
        }).on("mouseout", () => {
            if (!pinned) hideTooltipIfNotPinned();
        }).on("click", (event, d) => {
            event.stopPropagation();
            tooltip.style("display", "none"); // Hide tooltip on click
            pinned = true;
            pinnedNode = d;
            
            node.classed("faded", n => n.id !== d.id && !neighboring(d, n));
            link.classed("faded", l => l.source.id !== d.id && l.target.id !== d.id);
            label.classed("faded", n => n.id !== d.id && !neighboring(d, n));

            infoTitle.text(d.display_name);
            let infoHTML = `<h4>Preview</h4><p class="math-content">${cleanLatexForDisplay(d.content_preview || 'N/A')}</p>`;
            if (d.prerequisites_preview) {
                infoHTML += `<h4>Prerequisites</h4><p class="math-content">${cleanLatexForDisplay(d.prerequisites_preview)}</p>`;
            }
            infoBody.html(infoHTML);
            infoPanel.classed("visible", true);
            MathJax.typesetPromise([infoBody.node()]).catch(err => console.error(err));
        });

        link.on("mouseover", (event, d) => {
            const dependencyType = (d.dependency_type || 'INTERNAL').replace(/_/g, ' ').toUpperCase();
            let tooltipHTML = `<h4>Dependency Link</h4>
                           <p>${d.source.display_name} <br>
                              <span class="edge-type">â†’ ${dependencyType} â†’</span> <br>
                              ${d.target.display_name}</p>`;
            if (d.context) {
                tooltipHTML += `<p><strong>Context:</strong></p><div class="math-content">${cleanLatexForDisplay(d.context)}</div>`;
            }
            if (d.dependency) {
                tooltipHTML += `<p><strong>Justification:</strong></p><div class="math-content">${cleanLatexForDisplay(d.dependency)}</div>`;
            }
            tooltip.style("display", "block")
                .html(tooltipHTML)
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 28) + "px");

            MathJax.typesetPromise([tooltip.node()]).catch(err => console.error(err));
        }).on("mouseout", hideTooltipIfNotPinned);

        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            
            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
                
            label
                .attr("x", d => d.x)
                .attr("y", d => d.y);
        });

        const nodeLegendContainer = d3.select("#node-legend-container");
        const hiddenTypes = new Set();
        nodeTypes.forEach(type => {
            const item = nodeLegendContainer.append("div").attr("class", "legend-item").attr("id", `legend-item-${type}`);
            item.append("div").attr("class", "legend-color").style("background-color", nodeColors[type]);
            item.append("span").text(type.charAt(0).toUpperCase() + type.slice(1));
            
            item.on("click", () => {
                if (hiddenTypes.has(type)) {
                    hiddenTypes.delete(type);
                    item.classed("inactive", false);
                } else {
                    hiddenTypes.add(type);
                    item.classed("inactive", true);
                }
                updateVisibility();
            });
        });
        
        const edgeLegendContainer = d3.select("#edge-legend-container");
        edgeTypes.forEach(type => {
            const item = edgeLegendContainer.append("div").attr("class", "legend-item");
            item.append("div").attr("class", "edge-legend-line").style("background-color", edgeColors[type]);
            item.append("span").text(type.replace(/_/g, ' '));
        });

        function updateVisibility() {
            node.style("display", d => hiddenTypes.has(d.type) ? "none" : "");
            label.style("display", d => hiddenTypes.has(d.type) ? "none" : "");
            link.style("display", d => hiddenTypes.has(d.source.type) || hiddenTypes.has(d.target.type) ? "none" : "");
            simulation.alpha(0.3).restart();
        }

        d3.select("#center").on("click", () => {
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });

        function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
        function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
        function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
    </script>
</body>
</html>